with SPDM;

package SPDM_Responder is

   --  FIXME: Update transcript hash

   type DHE_Algo is
      (DA_FFDHE2048 =>  1,
       DA_FFDHE3072 =>  2,
       DA_FFDHE4096 =>  4,
       DA_SecP256r1 =>  8,
       DA_SecP384r1 => 16,
       DA_SecP521r1 => 32)
   with Size => 8;

   type AEAD_Algo is
      (AA_AES_128_GCM       => 1,
       AA_AES_256_GCM       => 2,
       AA_ChaCha20_Poly1305 => 4)
   with Size => 8;

   type Digests_Length is range 0 .. 512 with Size => 16;

   type Digests_Data is
      message
         Slot_0_Present : SPDM::Slot_Present;
         Slot_1_Present : SPDM::Slot_Present;
         Slot_2_Present : SPDM::Slot_Present;
         Slot_3_Present : SPDM::Slot_Present;
         Slot_4_Present : SPDM::Slot_Present;
         Slot_5_Present : SPDM::Slot_Present;
         Slot_6_Present : SPDM::Slot_Present;
         Slot_7_Present : SPDM::Slot_Present;
         Length : Digests_Length;
         Value : Opaque
            with Size => 8 * Length;
      end message;

   generic
      Transport : Channel with Readable, Writable;
      with function Plat_Cfg_CT_Exponent return SPDM::CT_Exponent;
      with function Plat_Cfg_Cap_MAC return Boolean;
      with function Plat_Cfg_Cap_Encrypt return Boolean;
      with function Plat_Cfg_Cap_Meas_Fresh return Boolean;
      with function Plat_Cfg_Cap_Meas return SPDM::Meas_Cap;
      with function Plat_Cfg_Cap_Chal return Boolean;
      with function Plat_Cfg_Cap_Cert return Boolean;
      with function Plat_Cfg_Cap_Cache return Boolean;
      with function Plat_Cfg_Cap_Handshake_In_The_Clear return Boolean;
      with function Plat_Cfg_Cap_Key_Upd return Boolean;
      with function Plat_Cfg_Cap_Hbeat return Boolean;
      with function Plat_Cfg_Cap_Encap return Boolean;
      with function Plat_Cfg_Cap_PSK return SPDM::PSK_Resp_Cap;
      with function Plat_Cfg_Cap_Key_Ex return Boolean;
      with function Plat_Cfg_Cap_Mut_Auth return Boolean;
      with function Plat_Cfg_Cap_Pub_Key_ID return Boolean;
      with function Plat_Cfg_Sel_Measurement_Hash_Algo
         (TPM_ALG_SHA_256     : Boolean;
          TPM_ALG_SHA_384     : Boolean;
          TPM_ALG_SHA_512     : Boolean;
          TPM_ALG_SHA3_256    : Boolean;
          TPM_ALG_SHA3_384    : Boolean;
          TPM_ALG_SHA3_512    : Boolean;
          Raw_Bit_Streams_Only : Boolean) return SPDM::Measurement_Hash_Algo;
      with function Plat_Cfg_Sel_Base_Asym_Algo (TPM_ALG_ECDSA_ECC_NIST_P384 : Boolean;
                                                 TPM_ALG_RSAPSS_4096         : Boolean;
                                                 TPM_ALG_RSASSA_4096         : Boolean;
                                                 TPM_ALG_ECDSA_ECC_NIST_P256 : Boolean;
                                                 TPM_ALG_RSAPSS_3072         : Boolean;
                                                 TPM_ALG_RSASSA_3072         : Boolean;
                                                 TPM_ALG_RSAPSS_2048         : Boolean;
                                                 TPM_ALG_RSASSA_2048         : Boolean;
                                                 TPM_ALG_ECDSA_ECC_NIST_P521 : Boolean) return SPDM::Base_Asym_Algo;
      with function Plat_Cfg_Sel_Base_Hash_Algo (TPM_ALG_SHA_256  : Boolean;
                                                 TPM_ALG_SHA_384  : Boolean;
                                                 TPM_ALG_SHA_512  : Boolean;
                                                 TPM_ALG_SHA3_256 : Boolean;
                                                 TPM_ALG_SHA3_384 : Boolean;
                                                 TPM_ALG_SHA3_512 : Boolean) return SPDM::Base_Hash_Algo;
      with function Plat_Cfg_Sel_DHE
         (Req_SecP521r1 : Boolean;
          Req_SecP384r1 : Boolean;
          Req_SecP256r1 : Boolean;
          Req_FFDHE4096 : Boolean;
          Req_FFDHE3072 : Boolean;
          Req_FFDHE2048 : Boolean) return SPDM_Responder::DHE_Algo;

      with function Plat_Cfg_Sel_AEAD
         (Req_ChaCha20_Poly1305 : Boolean;
          Req_AES_256_GCM       : Boolean;
          Req_AES_128_GCM       : Boolean) return SPDM_Responder::AEAD_Algo;

      with function Plat_Cfg_Sel_RBAA
         (Req_TPM_ALG_ECDSA_ECC_NIST_P384 : Boolean;
          Req_TPM_ALG_RSAPSS_4096         : Boolean;
          Req_TPM_ALG_RSASSA_4096         : Boolean;
          Req_TPM_ALG_ECDSA_ECC_NIST_P256 : Boolean;
          Req_TPM_ALG_RSAPSS_3072         : Boolean;
          Req_TPM_ALG_RSASSA_3072         : Boolean;
          Req_TPM_ALG_RSAPSS_2048         : Boolean;
          Req_TPM_ALG_RSASSA_2048         : Boolean;
          Req_TPM_ALG_ECDSA_ECC_NIST_P521 : Boolean) return SPDM::Base_Asym_Algo;

      with function Plat_Get_Digests_Data (Algo : SPDM::Measurement_Hash_Algo) return Digests_Data;

      with function Plat_Valid_Certificate_Request
         (Slot   : SPDM::Slot;
          Offset : SPDM::Offset;
          Length : SPDM::Length_16) return Boolean;

      with function Plat_Get_Certificate_Response
         (Slot   : SPDM::Slot;
          Offset : SPDM::Offset;
          Length : SPDM::Length_16) return SPDM::Certificate_Response;

      with function Plat_Get_Number_Of_Indices return SPDM::Measurement_Count;

      with function Plat_Get_Nonce return SPDM::Nonce;

      with function Plat_Get_DMTF_Measurement_Field (Index : SPDM::Index) return SPDM::DMTF_Measurement_Field;

   session Session with
      Initial => Init,
      Final => End_Session
   is
      Request                : SPDM::Request;
      Response               : SPDM::Response;
      Supp_Versions          : SPDM::Version_Number_Entries;
      Measurement_Hash_Algo  : SPDM::Measurement_Hash_Algo;
      Hash_Length            : SPDM::Hash_Length;
      Slot                   : SPDM::Slot;
      Offset                 : SPDM::Offset;
      Length                 : SPDM::Length_16;
      DHE_List               : SPDM::Req_Alg_Structs;
      AEAD_Cipher_Suite_List : SPDM::Req_Alg_Structs;
      Req_Base_Asym_Alg_List : SPDM::Req_Alg_Structs;
      Key_Schedule_List      : SPDM::Req_Alg_Structs;
      Resp_Alg_Structs       : SPDM::Resp_Alg_Structs;
   begin
      state Init
      is
      begin
         Supp_Versions'Reset;
         Supp_Versions'Append
            (SPDM::Version_Number_Entry'(Alpha                 => 0,
                                         Update_Version_Number => 0,
                                         Minor_Version         => 1,
                                         Major_Version         => 1));
         Hash_Length := 0;
         --  FIXME: Reset all state
      transition
         goto Receive_Get_Version
      exception
         goto Error_Unspecified
      end Init;

      state Receive_Get_Version
      is
      begin
         Transport'Read (Request);
      transition
         goto Prepare_Version
            --  FIXME: [161] After receiving a GET_VERSION request, the Responder shall cancel all previous requests
            --  from the same Requester. All active sessions between the Requester and the Responder are terminated,
            --  i.e., information (such as session keys, session IDs) for those sessions should not be used anymore.
            --  Additionally, this message shall clear or reset the previously Negotiated State, if any,
            --  in both the Requester and its corresponding Responder.
            if Request'Valid and Request.Code = SPDM::Get_Version
         goto Error_Unsupported_Request
            if Request'Valid
         goto Error_Invalid_Request
      end Receive_Get_Version;

      state Prepare_Version
      is
      begin
         Response := SPDM::Response'(Meas_Cap                                    => SPDM::Meas_Unsupported,
                                     Hash_Type                                   => SPDM::No_Measurement,
                                     Hash_Length                                 => 0,
                                     Signature_Length                            => 512,
                                     Exchange_Data_Length                        => 512,
                                     Handshake_In_The_Clear                      => True,
                                     Major_Version                               => 1,
                                     Minor_Version                               => 0,
                                     Code                                        => SPDM::Version,
                                     Version_Response_Param_1                    => 0,
                                     Version_Response_Param_2                    => 0,
                                     Version_Response_Reserved                   => 0,
                                     Version_Response_Version_Number_Entry_Count => 1,
                                     Version_Response_Version_Number_Entries     => Supp_Versions);
      transition
         goto Send_Version
      exception
         goto Error_Unspecified
      end Prepare_Version;

      state Send_Version
      is
      begin
         Transport'Write (Response);
      transition
         goto Receive_Get_Capabilities
      end Send_Version;

      state Receive_Get_Capabilities
      is
      begin
         Transport'Read (Request);
      transition
         goto Prepare_Capabilities
            if Request'Valid and Request.Code = SPDM::Get_Capabilities
         goto Error_Unsupported_Request
            if Request'Valid
         goto Error_Invalid_Request
      end Receive_Get_Capabilities;

      state Prepare_Capabilities
      is
         CT_Exponent                : SPDM::CT_Exponent;
         Cap_MAC                    : Boolean;
         Cap_Encrypt                : Boolean;
         Cap_Meas_Fresh             : Boolean;
         Cap_Meas                   : SPDM::Meas_Cap;
         Cap_Chal                   : Boolean;
         Cap_Cert                   : Boolean;
         Cap_Cache                  : Boolean;
         Cap_Handshake_In_The_Clear : Boolean;
         Cap_Key_Upd                : Boolean;
         Cap_Hbeat                  : Boolean;
         Cap_Encap                  : Boolean;
         Cap_PSK                    : SPDM::PSK_Resp_Cap;
         Cap_Key_Ex                 : Boolean;
         Cap_Mut_Auth               : Boolean;
         Cap_Pub_Key_ID             : Boolean;
      begin
         CT_Exponent                := Plat_Cfg_CT_Exponent;
         Cap_MAC                    := Plat_Cfg_Cap_MAC;
         Cap_Encrypt                := Plat_Cfg_Cap_Encrypt;
         Cap_Meas_Fresh             := Plat_Cfg_Cap_Meas_Fresh;
         Cap_Meas                   := Plat_Cfg_Cap_Meas;
         Cap_Chal                   := Plat_Cfg_Cap_Chal;
         Cap_Cert                   := Plat_Cfg_Cap_Cert;
         Cap_Cache                  := Plat_Cfg_Cap_Cache;
         Cap_Handshake_In_The_Clear := Plat_Cfg_Cap_Handshake_In_The_Clear;
         Cap_Key_Upd                := Plat_Cfg_Cap_Key_Upd;
         Cap_Hbeat                  := Plat_Cfg_Cap_Hbeat;
         Cap_Encap                  := Plat_Cfg_Cap_Encap;
         Cap_PSK                    := Plat_Cfg_Cap_PSK;
         Cap_Key_Ex                 := Plat_Cfg_Cap_Key_Ex;
         Cap_Mut_Auth               := Plat_Cfg_Cap_Mut_Auth;
         Cap_Pub_Key_ID             := Plat_Cfg_Cap_Pub_Key_ID;

         Response :=
            SPDM::Response'(Meas_Cap                                         => SPDM::Meas_Unsupported,
                            Hash_Type                                        => SPDM::No_Measurement,
                            Hash_Length                                      => 0,
                            Signature_Length                                 => 512,
                            Exchange_Data_Length                             => 512,
                            Handshake_In_The_Clear                           => True,
                            Major_Version                                    => 1,
                            Minor_Version                                    => 1,
                            Code                                             => SPDM::Capabilities,
                            Capabilities_Response_Param_1                    => 0,
                            Capabilities_Response_Param_2                    => 0,
                            Capabilities_Response_Reserved_1                 => 0,
                            Capabilities_Response_CT_Exponent                => CT_Exponent,
                            Capabilities_Response_Reserved_2                 => 0,
                            Capabilities_Response_MAC_Cap                    => Cap_MAC,
                            Capabilities_Response_Encrypt_Cap                => Cap_Encrypt,
                            Capabilities_Response_Meas_Fresh_Cap             => Cap_Meas_Fresh,
                            Capabilities_Response_Meas_Cap                   => Cap_Meas,
                            Capabilities_Response_Chal_Cap                   => Cap_Chal,
                            Capabilities_Response_Cert_Cap                   => Cap_Cert,
                            Capabilities_Response_Cache_Cap                  => Cap_Cache,
                            Capabilities_Response_Handshake_In_The_Clear_Cap => Cap_Handshake_In_The_Clear,
                            Capabilities_Response_Key_Upd_Cap                => Cap_Key_Upd,
                            Capabilities_Response_Hbeat_Cap                  => Cap_Hbeat,
                            Capabilities_Response_Encap_Cap                  => Cap_Encap,
                            Capabilities_Response_PSK_Cap                    => Cap_PSK,
                            Capabilities_Response_Key_Ex_Cap                 => Cap_Key_Ex,
                            Capabilities_Response_Mut_Auth_Cap               => Cap_Mut_Auth,
                            Capabilities_Response_Reserved_4                 => 0,
                            Capabilities_Response_Pub_Key_ID_Cap             => Cap_Pub_Key_ID);
      transition
         goto Send_Capabilities
      exception
         goto Error_Unspecified
      end Prepare_Capabilities;

      state Send_Capabilities
      is
      begin
         Transport'Write (Response);
      transition
         goto Receive_Negotiate_Algorithms
      end Send_Capabilities;

      state Receive_Negotiate_Algorithms
      is
      begin
         Transport'Read (Request);
      transition
         goto Check_Algorithms_DHE
            if Request'Valid and Request.Code = SPDM::Negotiate_Algorithms
         goto Error_Unsupported_Request
            if Request'Valid
         goto Error_Invalid_Request
      end Receive_Negotiate_Algorithms;

      state Check_Algorithms_DHE
      is
      begin
         Resp_Alg_Structs'Reset;
         DHE_List := [for A in Request.Negotiate_Algorithms_Request_Req_Alg_Structs
                      if A.Alg_Type = SPDM::DHE => A];
      transition
         goto Prepare_Algorithms_DHE
            if DHE_List'Size > 0
         goto Check_Algorithms_AEAD_Cipher_Suite
      exception
         goto Error_Unspecified
      end Check_Algorithms_DHE;

      state Prepare_Algorithms_DHE
      is
         Sel_SecP521r1 : Boolean;
         Sel_SecP384r1 : Boolean;
         Sel_SecP256r1 : Boolean;
         Sel_FFDHE4096 : Boolean;
         Sel_FFDHE3072 : Boolean;
         Sel_FFDHE2048 : Boolean;
         DHE           : SPDM::Alg_Struct;
         DHE_Algo      : SPDM_Responder::DHE_Algo;
      begin
         DHE := DHE_List'Head;
         DHE_Algo := Plat_Cfg_Sel_DHE
            (DHE.DHE_SecP521r1,
             DHE.DHE_SecP384r1,
             DHE.DHE_SecP256r1,
             DHE.DHE_FFDHE4096,
             DHE.DHE_FFDHE3072,
             DHE.DHE_FFDHE2048);

         Sel_SecP521r1 := DHE_Algo = DA_SecP521r1;
         Sel_SecP384r1 := DHE_Algo = DA_SecP384r1;
         Sel_SecP256r1 := DHE_Algo = DA_SecP256r1;
         Sel_FFDHE4096 := DHE_Algo = DA_FFDHE4096;
         Sel_FFDHE3072 := DHE_Algo = DA_FFDHE3072;
         Sel_FFDHE2048 := DHE_Algo = DA_FFDHE2048;

         Resp_Alg_Structs'Append (
            SPDM::Alg_Struct'(
               Alg_Type        => SPDM::DHE,
               Fixed_Alg_Count => 2,
               Ext_Alg_Count   => 0,
               DHE_Reserved_1  => 0,
               DHE_SecP521r1   => Sel_SecP521r1,
               DHE_SecP384r1   => Sel_SecP384r1,
               DHE_SecP256r1   => Sel_SecP256r1,
               DHE_FFDHE4096   => Sel_FFDHE4096,
               DHE_FFDHE3072   => Sel_FFDHE3072,
               DHE_FFDHE2048   => Sel_FFDHE2048,
               DHE_Reserved_2  => 0,
               Alg_External    => [])
         );
      transition
         goto Check_Algorithms_AEAD_Cipher_Suite
      exception
         goto Error_Unspecified
      end Prepare_Algorithms_DHE;

      state Check_Algorithms_AEAD_Cipher_Suite
      is
      begin
         AEAD_Cipher_Suite_List := [for A in Request.Negotiate_Algorithms_Request_Req_Alg_Structs
                                    if A.Alg_Type = SPDM::AEAD_Cipher_Suite => A];
      transition
         goto Prepare_Algorithms_AEAD_Cipher_Suite
            if AEAD_Cipher_Suite_List'Size > 0
         goto Check_Algorithms_Req_Base_Asym_Alg
      exception
         goto Error_Unspecified
      end Check_Algorithms_AEAD_Cipher_Suite;

      state Prepare_Algorithms_AEAD_Cipher_Suite
      is
         AEAD_Cipher_Suite     : SPDM::Alg_Struct;
         AEAD_Algo             : SPDM_Responder::AEAD_Algo;
         Sel_ChaCha20_Poly1305 : Boolean;
         Sel_AES_256_GCM       : Boolean;
         Sel_AES_128_GCM       : Boolean;
      begin
         AEAD_Cipher_Suite := AEAD_Cipher_Suite_List'Head;

         AEAD_Algo := Plat_Cfg_Sel_AEAD
            (AEAD_Cipher_Suite.AEAD_ChaCha20_Poly1305,
             AEAD_Cipher_Suite.AEAD_AES_256_GCM,
             AEAD_Cipher_Suite.AEAD_AES_128_GCM);

         Sel_ChaCha20_Poly1305 := AEAD_Algo = AA_ChaCha20_Poly1305;
         Sel_AES_256_GCM       := AEAD_Algo = AA_AES_256_GCM;
         Sel_AES_128_GCM       := AEAD_Algo = AA_AES_128_GCM;

         Resp_Alg_Structs'Append (
            SPDM::Alg_Struct'(
               Alg_Type               => SPDM::AEAD_Cipher_Suite,
               Fixed_Alg_Count        => 2,
               Ext_Alg_Count          => 0,
               AEAD_Reserved_1        => 0,
               AEAD_ChaCha20_Poly1305 => Sel_ChaCha20_Poly1305,
               AEAD_AES_256_GCM       => Sel_AES_256_GCM,
               AEAD_AES_128_GCM       => Sel_AES_128_GCM,
               AEAD_Reserved_2        => 0,
               Alg_External           => [])
         );
      transition
         goto Check_Algorithms_Req_Base_Asym_Alg
      exception
         goto Error_Unspecified
      end Prepare_Algorithms_AEAD_Cipher_Suite;

      state Check_Algorithms_Req_Base_Asym_Alg
      is
      begin
         Req_Base_Asym_Alg_List := [for A in Request.Negotiate_Algorithms_Request_Req_Alg_Structs
                                    if A.Alg_Type = SPDM::Req_Base_Asym_Alg => A];
      transition
         goto Prepare_Algorithms_Req_Base_Asym_Alg
            if Req_Base_Asym_Alg_List'Size > 0
         goto Check_Algorithms_Key_Schedule
      exception
         goto Error_Unspecified
      end Check_Algorithms_Req_Base_Asym_Alg;

      state Prepare_Algorithms_Req_Base_Asym_Alg
      is
         Req_Base_Asym_Alg               : SPDM::Alg_Struct;
         Sel_TPM_ALG_ECDSA_ECC_NIST_P384 : Boolean;
         Sel_TPM_ALG_RSAPSS_4096         : Boolean;
         Sel_TPM_ALG_RSASSA_4096         : Boolean;
         Sel_TPM_ALG_ECDSA_ECC_NIST_P256 : Boolean;
         Sel_TPM_ALG_RSAPSS_3072         : Boolean;
         Sel_TPM_ALG_RSASSA_3072         : Boolean;
         Sel_TPM_ALG_RSAPSS_2048         : Boolean;
         Sel_TPM_ALG_RSASSA_2048         : Boolean;
         Sel_TPM_ALG_ECDSA_ECC_NIST_P521 : Boolean;
         RBAA_Algo                       : SPDM::Base_Asym_Algo;
      begin
         Req_Base_Asym_Alg := Req_Base_Asym_Alg_List'Head;
         RBAA_Algo := Plat_Cfg_Sel_RBAA
            (Req_Base_Asym_Alg.RBAA_TPM_ALG_ECDSA_ECC_NIST_P384,
             Req_Base_Asym_Alg.RBAA_TPM_ALG_RSAPSS_4096,
             Req_Base_Asym_Alg.RBAA_TPM_ALG_RSASSA_4096,
             Req_Base_Asym_Alg.RBAA_TPM_ALG_ECDSA_ECC_NIST_P256,
             Req_Base_Asym_Alg.RBAA_TPM_ALG_RSAPSS_3072,
             Req_Base_Asym_Alg.RBAA_TPM_ALG_RSASSA_3072,
             Req_Base_Asym_Alg.RBAA_TPM_ALG_RSAPSS_2048,
             Req_Base_Asym_Alg.RBAA_TPM_ALG_RSASSA_2048,
             Req_Base_Asym_Alg.RBAA_TPM_ALG_ECDSA_ECC_NIST_P521);

         Sel_TPM_ALG_ECDSA_ECC_NIST_P384 := RBAA_Algo = SPDM::BA_TPM_ALG_ECDSA_ECC_NIST_P384;
         Sel_TPM_ALG_RSAPSS_4096         := RBAA_Algo = SPDM::BA_TPM_ALG_RSAPSS_4096;
         Sel_TPM_ALG_RSASSA_4096         := RBAA_Algo = SPDM::BA_TPM_ALG_RSASSA_4096;
         Sel_TPM_ALG_ECDSA_ECC_NIST_P256 := RBAA_Algo = SPDM::BA_TPM_ALG_ECDSA_ECC_NIST_P256;
         Sel_TPM_ALG_RSAPSS_3072         := RBAA_Algo = SPDM::BA_TPM_ALG_RSAPSS_3072;
         Sel_TPM_ALG_RSASSA_3072         := RBAA_Algo = SPDM::BA_TPM_ALG_RSASSA_3072;
         Sel_TPM_ALG_RSAPSS_2048         := RBAA_Algo = SPDM::BA_TPM_ALG_RSAPSS_2048;
         Sel_TPM_ALG_RSASSA_2048         := RBAA_Algo = SPDM::BA_TPM_ALG_RSASSA_2048;
         Sel_TPM_ALG_ECDSA_ECC_NIST_P521 := RBAA_Algo = SPDM::BA_TPM_ALG_ECDSA_ECC_NIST_P521;

         Resp_Alg_Structs'Append (
            SPDM::Alg_Struct'(
               Alg_Type                         => SPDM::Req_Base_Asym_Alg,
               Fixed_Alg_Count                  => 2,
               Ext_Alg_Count                    => 0,
               RBAA_TPM_ALG_ECDSA_ECC_NIST_P384 => Sel_TPM_ALG_ECDSA_ECC_NIST_P384,
               RBAA_TPM_ALG_RSAPSS_4096         => Sel_TPM_ALG_RSAPSS_4096,
               RBAA_TPM_ALG_RSASSA_4096         => Sel_TPM_ALG_RSASSA_4096,
               RBAA_TPM_ALG_ECDSA_ECC_NIST_P256 => Sel_TPM_ALG_ECDSA_ECC_NIST_P256,
               RBAA_TPM_ALG_RSAPSS_3072         => Sel_TPM_ALG_RSAPSS_3072,
               RBAA_TPM_ALG_RSASSA_3072         => Sel_TPM_ALG_RSASSA_3072,
               RBAA_TPM_ALG_RSAPSS_2048         => Sel_TPM_ALG_RSAPSS_2048,
               RBAA_TPM_ALG_RSASSA_2048         => Sel_TPM_ALG_RSASSA_2048,
               RBAA_Reserved_1                  => 0,
               RBAA_TPM_ALG_ECDSA_ECC_NIST_P521 => Sel_TPM_ALG_ECDSA_ECC_NIST_P521,
               Alg_External                     => [])
         );
      transition
         goto Check_Algorithms_Key_Schedule
      exception
         goto Error_Unspecified
      end Prepare_Algorithms_Req_Base_Asym_Alg;

      state Check_Algorithms_Key_Schedule
      is
      begin
         Key_Schedule_List := [for A in Request.Negotiate_Algorithms_Request_Req_Alg_Structs
                               if A.Alg_Type = SPDM::Key_Schedule => A];
      transition
         goto Prepare_Algorithms_Key_Schedule
            if Key_Schedule_List'Size > 0
         goto Prepare_Algorithms
      exception
         goto Error_Unspecified
      end Check_Algorithms_Key_Schedule;

      state Prepare_Algorithms_Key_Schedule
      is
         Key_Schedule : SPDM::Alg_Struct;
      begin
         Key_Schedule := Key_Schedule_List'Head;
         Resp_Alg_Structs'Append (
            SPDM::Alg_Struct'(
               Alg_Type                         => SPDM::Key_Schedule,
               Fixed_Alg_Count                  => 2,
               Ext_Alg_Count                    => 0,
               KS_Reserved_1                    => 0,
               KS_SPDM                          => Key_Schedule.KS_SPDM,
               KS_Reserved_2                    => 0,
               Alg_External                     => [])
         );
      transition
         goto Prepare_Algorithms
      exception
         goto Error_Unspecified
      end Prepare_Algorithms_Key_Schedule;

      state Prepare_Algorithms
      is
         Base_Hash_Sel : SPDM::Base_Hash_Algo;
         Base_Asym_Sel : SPDM::Base_Asym_Algo;
         Ext_Asym      : SPDM::Ext_Algs;
         Ext_Hash      : SPDM::Ext_Algs;
      begin
         Measurement_Hash_Algo := Plat_Cfg_Sel_Measurement_Hash_Algo
                                     (Request.Negotiate_Algorithms_Request_Base_Hash_Algo_TPM_ALG_SHA_256,
                                      Request.Negotiate_Algorithms_Request_Base_Hash_Algo_TPM_ALG_SHA_384,
                                      Request.Negotiate_Algorithms_Request_Base_Hash_Algo_TPM_ALG_SHA_512,
                                      Request.Negotiate_Algorithms_Request_Base_Hash_Algo_TPM_ALG_SHA3_256,
                                      Request.Negotiate_Algorithms_Request_Base_Hash_Algo_TPM_ALG_SHA3_384,
                                      Request.Negotiate_Algorithms_Request_Base_Hash_Algo_TPM_ALG_SHA3_512,
                                      False);

         Base_Asym_Sel := Plat_Cfg_Sel_Base_Asym_Algo
                             (Request.Negotiate_Algorithms_Request_Base_Asym_Algo_TPM_ALG_ECDSA_ECC_NIST_P384,
                              Request.Negotiate_Algorithms_Request_Base_Asym_Algo_TPM_ALG_RSAPSS_4096,
                              Request.Negotiate_Algorithms_Request_Base_Asym_Algo_TPM_ALG_RSASSA_4096,
                              Request.Negotiate_Algorithms_Request_Base_Asym_Algo_TPM_ALG_ECDSA_ECC_NIST_P256,
                              Request.Negotiate_Algorithms_Request_Base_Asym_Algo_TPM_ALG_RSAPSS_3072,
                              Request.Negotiate_Algorithms_Request_Base_Asym_Algo_TPM_ALG_RSASSA_3072,
                              Request.Negotiate_Algorithms_Request_Base_Asym_Algo_TPM_ALG_RSAPSS_2048,
                              Request.Negotiate_Algorithms_Request_Base_Asym_Algo_TPM_ALG_RSASSA_2048,
                              Request.Negotiate_Algorithms_Request_Base_Asym_Algo_TPM_ALG_ECDSA_ECC_NIST_P521);

         Base_Hash_Sel := Plat_Cfg_Sel_Base_Hash_Algo
                             (Request.Negotiate_Algorithms_Request_Base_Hash_Algo_TPM_ALG_SHA_256,
                              Request.Negotiate_Algorithms_Request_Base_Hash_Algo_TPM_ALG_SHA_384,
                              Request.Negotiate_Algorithms_Request_Base_Hash_Algo_TPM_ALG_SHA_512,
                              Request.Negotiate_Algorithms_Request_Base_Hash_Algo_TPM_ALG_SHA3_256,
                              Request.Negotiate_Algorithms_Request_Base_Hash_Algo_TPM_ALG_SHA3_384,
                              Request.Negotiate_Algorithms_Request_Base_Hash_Algo_TPM_ALG_SHA3_512);

         Response :=
            SPDM::Response'(Meas_Cap                                          => SPDM::Meas_Unsupported,
                            Hash_Type                                         => SPDM::No_Measurement,
                            Hash_Length                                       => 0,
                            Signature_Length                                  => 512,
                            Exchange_Data_Length                              => 512,
                            Handshake_In_The_Clear                            => True,
                            Major_Version                                     => 1,
                            Minor_Version                                     => 1,
                            Code                                              => SPDM::Algorithms,
                            Algorithms_Response_Resp_Alg_Struct_Count         => 4,
                            Algorithms_Response_Param_2                       => 0,
                            Algorithms_Response_Length                        => 36 + Resp_Alg_Structs'Size / 8,
                            Algorithms_Response_Measurement_Specification_Sel => SPDM::DMTF,
                            Algorithms_Response_Reserved_1                    => 0,
                            Algorithms_Response_Measurement_Hash_Algo         => Measurement_Hash_Algo,
                            Algorithms_Response_Base_Asym_Sel                 => Base_Asym_Sel,
                            Algorithms_Response_Base_Hash_Sel                 => Base_Hash_Sel,
                            Algorithms_Response_Reserved_2                    => 0,
                            Algorithms_Response_Reserved_3                    => 0,
                            Algorithms_Response_Ext_Asym_Sel_Count            => 0,
                            Algorithms_Response_Ext_Hash_Sel_Count            => 0,
                            Algorithms_Response_Reserved_4                    => 0,
                            Algorithms_Response_Ext_Asym                      => Ext_Asym,
                            Algorithms_Response_Ext_Hash                      => Ext_Hash,
                            Algorithms_Response_Resp_Alg_Structs              => Resp_Alg_Structs);
      transition
         --  ISSUE: Componolit/RecordFlux#907
         --  This cannot be done more elegantly right now
         goto Set_Hash_Len_32
            if Measurement_Hash_Algo = SPDM::MH_TPM_ALG_SHA_256
               or Measurement_Hash_Algo = SPDM::MH_TPM_ALG_SHA3_256
         goto Set_Hash_Len_48
            if Measurement_Hash_Algo = SPDM::MH_TPM_ALG_SHA_384
               or Measurement_Hash_Algo = SPDM::MH_TPM_ALG_SHA3_384
         goto Set_Hash_Len_64
            if Measurement_Hash_Algo = SPDM::MH_TPM_ALG_SHA_512
               or Measurement_Hash_Algo = SPDM::MH_TPM_ALG_SHA3_512
         goto Error_Invalid_Request
      exception
         goto Error_Unspecified
      end Prepare_Algorithms;

      --  ISSUE: Componolit/RecordFlux#907
      state Set_Hash_Len_32
      is
      begin
         Hash_Length := 32;
      transition
         goto Send_Algorithms
      end Set_Hash_Len_32;

      --  ISSUE: Componolit/RecordFlux#907
      state Set_Hash_Len_48
      is
      begin
         Hash_Length := 48;
      transition
         goto Send_Algorithms
      end Set_Hash_Len_48;

      --  ISSUE: Componolit/RecordFlux#907
      state Set_Hash_Len_64
      is
      begin
         Hash_Length := 64;
      transition
         goto Send_Algorithms
      end Set_Hash_Len_64;

      state Send_Algorithms
      is
      begin
         Transport'Write (Response);
      transition
         goto Receive_Get_Digests
      end Send_Algorithms;

      state Receive_Get_Digests
      is
      begin
         Transport'Read (Request);
      transition
         goto Prepare_Digests
            if Request'Valid and Request.Code = SPDM::Get_Digests
         goto Error_Unsupported_Request
            if Request'Valid
         goto Error_Invalid_Request
      end Receive_Get_Digests;

      state Prepare_Digests
      is
         Digests_Data   : Digests_Data;
         Slot_0_Present : SPDM::Slot_Present;
         Slot_1_Present : SPDM::Slot_Present;
         Slot_2_Present : SPDM::Slot_Present;
         Slot_3_Present : SPDM::Slot_Present;
         Slot_4_Present : SPDM::Slot_Present;
         Slot_5_Present : SPDM::Slot_Present;
         Slot_6_Present : SPDM::Slot_Present;
         Slot_7_Present : SPDM::Slot_Present;
      begin
         Digests_Data := Plat_Get_Digests_Data (Measurement_Hash_Algo);
         Slot_0_Present := Digests_Data.Slot_0_Present;
         Slot_1_Present := Digests_Data.Slot_1_Present;
         Slot_2_Present := Digests_Data.Slot_2_Present;
         Slot_3_Present := Digests_Data.Slot_3_Present;
         Slot_4_Present := Digests_Data.Slot_4_Present;
         Slot_5_Present := Digests_Data.Slot_5_Present;
         Slot_6_Present := Digests_Data.Slot_6_Present;
         Slot_7_Present := Digests_Data.Slot_7_Present;

         Response := SPDM::Response'(Meas_Cap                                    => SPDM::Meas_Unsupported,
                                     Hash_Type                                   => SPDM::No_Measurement,
                                     Hash_Length                                 => Hash_Length,
                                     Signature_Length                            => 512,
                                     Exchange_Data_Length                        => 512,
                                     Handshake_In_The_Clear                      => True,
                                     Major_Version                               => 1,
                                     Minor_Version                               => 1,
                                     Code                                        => SPDM::Digests,
                                     Digests_Response_Param_1                    => 0,
                                     Digests_Response_Slot_Mask_Slot_7_Present   => Slot_7_Present,
                                     Digests_Response_Slot_Mask_Slot_6_Present   => Slot_6_Present,
                                     Digests_Response_Slot_Mask_Slot_5_Present   => Slot_5_Present,
                                     Digests_Response_Slot_Mask_Slot_4_Present   => Slot_4_Present,
                                     Digests_Response_Slot_Mask_Slot_3_Present   => Slot_3_Present,
                                     Digests_Response_Slot_Mask_Slot_2_Present   => Slot_2_Present,
                                     Digests_Response_Slot_Mask_Slot_1_Present   => Slot_1_Present,
                                     Digests_Response_Slot_Mask_Slot_0_Present   => Slot_0_Present,
                                     Digests_Response_Digests_Data               => Digests_Data.Value);
      transition
         goto Send_Digests
      exception
         goto Error_Unspecified
      end Prepare_Digests;

      state Send_Digests
      is
      begin
         Transport'Write (Response);
      transition
         goto Receive_Get_Certificate
      end Send_Digests;

      state Receive_Get_Certificate
      is
      begin
         Transport'Read (Request);
      transition
         goto Check_Certificate
            if Request'Valid and Request.Code = SPDM::Get_Certificate
         goto Error_Unsupported_Request
            if Request'Valid
         goto Error_Invalid_Request
      end Receive_Get_Certificate;

      state Check_Certificate
      is
         Valid : Boolean;
      begin
         Slot   := Request.Get_Certificate_Request_Slot;
         Offset := Request.Get_Certificate_Request_Offset;
         Length := Request.Get_Certificate_Request_Length;
         Valid  := Plat_Valid_Certificate_Request (Slot, Offset, Length);
      transition
         goto Prepare_Certificate
            if Valid
         goto Error_Invalid_Request
      exception
         goto Error_Unspecified
      end Check_Certificate;

      state Prepare_Certificate
      is
         Cert                  : SPDM::Certificate_Response;
         Cert_Slot             : SPDM::Slot;
         Cert_Portion_Length   : SPDM::Portion_Length_16;
         Cert_Remainder_Length : SPDM::Length_16;
      begin
         Cert                  := Plat_Get_Certificate_Response (Slot, Offset, Length);
         Cert_Slot             := Cert.Slot;
         Cert_Portion_Length   := Cert.Portion_Length;
         Cert_Remainder_Length := Cert.Remainder_Length;

         Response := SPDM::Response'(Meas_Cap                              => SPDM::Meas_Unsupported,
                                     Hash_Type                             => SPDM::No_Measurement,
                                     Hash_Length                           => Hash_Length,
                                     Signature_Length                      => 512,
                                     Exchange_Data_Length                  => 512,
                                     Handshake_In_The_Clear                => True,
                                     Major_Version                         => 1,
                                     Minor_Version                         => 1,
                                     Code                                  => SPDM::Certificate,
                                     Certificate_Response_Slot             => Cert_Slot,
                                     Certificate_Response_Param_2          => 0,
                                     Certificate_Response_Portion_Length   => Cert_Portion_Length,
                                     Certificate_Response_Remainder_Length => Cert_Remainder_Length,
                                     Certificate_Response_Cert_Chain       => Cert.Cert_Chain);
      transition
         goto Send_Certificate
      exception
         goto Error_Unspecified
      end Prepare_Certificate;

      state Send_Certificate
      is
      begin
         Transport'Write (Response);
      transition
         goto Receive_Get_Certificate
            if Response.Certificate_Response_Remainder_Length > 0
         goto Receive_Get_Measurements
      end Send_Certificate;

      state Receive_Get_Measurements
      is
      begin
         Transport'Read (Request);
      transition
         goto Prepare_Measurements
            if Request'Valid and Request.Code = SPDM::Get_Measurements
         goto Error_Unsupported_Request
            if Request'Valid
         goto Error_Invalid_Request
      end Receive_Get_Measurements;

      state Prepare_Measurements
      is
      begin
      transition
         goto Prepare_Measurements_Number_Of_Indices
            if Request.Get_Measurements_Request_Measurement_Operation = 0
         goto Prepare_Measurements_Records
      end Prepare_Measurements;

      state Prepare_Measurements_Records
      is
         Measurement_Record : SPDM::Measurement_Record;
         Measurement_Field : SPDM::DMTF_Measurement_Field;
         Nonce : SPDM::Nonce;
      begin
         Nonce := Plat_Get_Nonce;
         Measurement_Field := Plat_Get_DMTF_Measurement_Field (Request.Get_Measurements_Request_Measurement_Operation);
         Measurement_Record'Append (SPDM::Measurement_Block'
            (Index                                             =>
               Request.Get_Measurements_Request_Measurement_Operation,
             Measurement_Specification                         => SPDM::DMTF,
             Measurement_Length                                => Measurement_Field'Size / 8,
             DMTF_Measurement_Measurement_Value_Representation => Measurement_Field.Measurement_Value_Representation,
             DMTF_Measurement_Measurement_Value_Type           => Measurement_Field.Measurement_Value_Type,
             DMTF_Measurement_Measurement_Value_Length         => Measurement_Field.Measurement_Value_Length,
             DMTF_Measurement_Measurement_Value                => Measurement_Field.Measurement_Value));
         Response := SPDM::Response'(Meas_Cap                              => SPDM::Meas_Unsupported,
                                     Hash_Type                             => SPDM::No_Measurement,
                                     Hash_Length                           => Hash_Length,
                                     Signature_Length                      => 0,
                                     Exchange_Data_Length                  => 512,
                                     Handshake_In_The_Clear                => True,
                                     Major_Version                         => 1,
                                     Minor_Version                         => 1,
                                     Code                                  => SPDM::Measurements,
                                     Measurements_Response_Number_Of_Indices => 1,
                                     Measurements_Response_Reserved_1 => 0,
                                     Measurements_Response_Slot_ID => SPDM::NS_0,
                                     Measurements_Response_Number_Of_Blocks => 1,
                                     Measurements_Response_Measurement_Record_Length => Measurement_Record'Size / 8,
                                     Measurements_Response_Measurement_Record => Measurement_Record,
                                     Measurements_Response_Nonce_Data => Nonce.Data,
                                     Measurements_Response_Opaque_Length => 0,
                                     Measurements_Response_Opaque_Data => []);
      transition
         goto Send_Measurements
      exception
         goto Error_Unspecified
      end Prepare_Measurements_Records;

      state Prepare_Measurements_Number_Of_Indices
      is
         Measurement_Record : SPDM::Measurement_Record;
         Number_Of_Indices : SPDM::Measurement_Count;
         Nonce : SPDM::Nonce;
      begin
         Nonce := Plat_Get_Nonce;
         Number_Of_Indices := Plat_Get_Number_Of_Indices;
         Response := SPDM::Response'(Meas_Cap                              => SPDM::Meas_Unsupported,
                                     Hash_Type                             => SPDM::No_Measurement,
                                     Hash_Length                           => Hash_Length,
                                     Signature_Length                      => 0,
                                     Exchange_Data_Length                  => 512,
                                     Handshake_In_The_Clear                => True,
                                     Major_Version                         => 1,
                                     Minor_Version                         => 1,
                                     Code                                  => SPDM::Measurements,
                                     Measurements_Response_Number_Of_Indices => Number_Of_Indices,
                                     Measurements_Response_Reserved_1 => 0,
                                     Measurements_Response_Slot_ID => SPDM::NS_0,
                                     Measurements_Response_Number_Of_Blocks => 0,
                                     Measurements_Response_Measurement_Record_Length => 0,
                                     Measurements_Response_Measurement_Record => Measurement_Record,
                                     Measurements_Response_Nonce_Data => Nonce.Data,
                                     Measurements_Response_Opaque_Length => 0,
                                     Measurements_Response_Opaque_Data => []);
      transition
         goto Send_Measurements
      exception
         goto Error_Unspecified
      end Prepare_Measurements_Number_Of_Indices;

      state Send_Measurements
      is
      begin
         Transport'Write (Response);
      transition
         goto Receive_Get_Measurements
      end Send_Measurements;

      state Error_Unsupported_Request
      is
      begin
         Response :=
            SPDM::Response'(Meas_Cap                             => SPDM::Meas_Unsupported,
                            Hash_Type                            => SPDM::No_Measurement,
                            Hash_Length                          => 64,
                            Signature_Length                     => 512,
                            Exchange_Data_Length                 => 512,
                            Handshake_In_The_Clear               => True,
                            Major_Version                        => 1,
                            Minor_Version                        => 1,
                            Code                                 => SPDM::Error,
                            Error_Response_Error_Code            => SPDM::Unsupported_Request,
                            Error_Response_Request_Response_Code => Request.Code);
      transition
         goto Send_Error
      exception
         goto End_Session
      end Error_Unsupported_Request;

      state Error_Invalid_Request
      is
      begin
         Response :=
            SPDM::Response'(Meas_Cap                       => SPDM::Meas_Unsupported,
                            Hash_Type                      => SPDM::No_Measurement,
                            Hash_Length                    => 64,
                            Signature_Length               => 512,
                            Exchange_Data_Length           => 512,
                            Handshake_In_The_Clear         => True,
                            Major_Version                  => 1,
                            Minor_Version                  => 1,
                            Code                           => SPDM::Error,
                            Error_Response_Error_Code      => SPDM::Invalid_Request,
                            Error_Response_Zero_Error_Data => 0);
      transition
         goto Send_Error
      exception
         goto End_Session
      end Error_Invalid_Request;

      state Error_Unspecified
      is
      begin
         Response :=
            SPDM::Response'(Meas_Cap                       => SPDM::Meas_Unsupported,
                            Hash_Type                      => SPDM::No_Measurement,
                            Hash_Length                    => 64,
                            Signature_Length               => 512,
                            Exchange_Data_Length           => 512,
                            Handshake_In_The_Clear         => True,
                            Major_Version                  => 1,
                            Minor_Version                  => 1,
                            Code                           => SPDM::Error,
                            Error_Response_Error_Code      => SPDM::Unspecified,
                            Error_Response_Zero_Error_Data => 0);
      transition
         goto Send_Error
      exception
         goto End_Session
      end Error_Unspecified;

      state Send_Error
      is
      begin
         Transport'Write (Response);
      transition
         goto Init
      end Send_Error;

      state End_Session is null state;
   end Session;

end SPDM_Responder;
